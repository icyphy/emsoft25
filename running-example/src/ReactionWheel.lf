target C {
    scheduler: STATIC,
    build-type: Debug,
    // platform: FlexPRET,
    workers: 2
  }
  
  preamble {=
    #include <string.h>
    // #include <flexpret/flexpret.h>
  
    // #define LAG() (rdtime() - ((uint32_t)lf_time_logical()))
  
    // #define PRINT_LAGS
    #ifdef PRINT_LAGS
    #define PRINT_LAG(module) lf_print("Lag in " #module " = %lu", LAG())
    #else
    #define PRINT_LAG(module)
    #endif
  
    // #define CALC_WCET
    #ifdef CALC_WCET
    #define WCET_BEGIN() uint32_t __t1 = rdtime()
    #define WCET_END() uint32_t __t2 = rdtime()
    #define WCET_REPORT(module) lf_print("WCET of " #module " = %lu", __t2 - __t1)
    #else
    #define WCET_BEGIN()
    #define WCET_END()
    #define WCET_REPORT(module)
    #endif
  
    #define TAKE_TIME(N) do {volatile int __x; for (int i = 0; i<N;i++) {__x++;}} while(0)
  
    typedef struct {
      float x;
      float y;
      float z;
    } FloatVec3;
  
  =}
  
  reactor Controller(period=100ms) {
      input current_angle: FloatVec3
      input current_speed: FloatVec3
      input desired_angle: FloatVec3
  
      state current_angle: FloatVec3
      state current_speed: FloatVec3
      state desired_angle: FloatVec3
      state last_update: time = 0
      state last_error: FloatVec3
      state error_accumulator: FloatVec3
  
      output control_signal: FloatVec3
  
      preamble {=
      =}
  
      @wcet("700 usec")
      reaction(current_speed, current_angle) -> control_signal {=
          WCET_BEGIN();
          self->current_speed.x = current_speed->value.x;
          self->current_speed.y = current_speed->value.y;
          self->current_speed.z = current_speed->value.z;
          self->current_angle.x = current_angle->value.x;
          self->current_angle.y = current_angle->value.y;
          self->current_angle.z = current_angle->value.z;
          const double p_controller_value = -5;
          const double i_controller_value = -0.1;
          const double d_controller_value = 0;
  
          if (self->last_update == NEVER){
              #ifndef NDEBUG
              lf_print("First update");
              #endif
              self->last_update = lf_time_logical();
              return;
          }
  
          unsigned long long current_tag = (lf_time_logical());
  
          unsigned long long time_diff = (current_tag - self->last_update);
          #ifndef NDEBUG
          lf_print("T = %lu OT = %lu DT = %lu", current_tag, self->last_update, time_diff);
          #endif
          FloatVec3 velocity_vector;
          velocity_vector.x = (self->current_angle.x - self->desired_angle.x)/( ((float)time_diff) * 0.000000001 );
          velocity_vector.y = (self->current_angle.y - self->desired_angle.y)/( ((float)time_diff) * 0.000000001 );
          velocity_vector.z = (self->current_angle.z - self->desired_angle.z)/( ((float)time_diff) * 0.000000001 );
          #ifndef NDEBUG
          lf_print("velocity_vector = %f %f %f", velocity_vector.x, velocity_vector.y, velocity_vector.z);
          #endif
          FloatVec3 error;
          error.x = (self->current_angle.x - self->desired_angle.x);
          error.y = (self->current_angle.y - self->desired_angle.y);
          error.z = (self->current_angle.z - self->desired_angle.z);
  
          #ifndef NDEBUG
          lf_print("Error = %f %f %f", error.x, error.y, error.z);
          #endif
  
          control_signal->value.x =
                p_controller_value * velocity_vector.x  // present component
              + i_controller_value * self->error_accumulator.x // integral component
              + d_controller_value * (self->last_error.x - error.x); // differential component
          control_signal->value.y =
                p_controller_value * velocity_vector.y  // present component
              + i_controller_value * self->error_accumulator.y // integral component
              + d_controller_value * (self->last_error.y - error.y); // differential component
          control_signal->value.z =
                p_controller_value * velocity_vector.z  // present component
              + i_controller_value * self->error_accumulator.z // integral component
              + d_controller_value * (self->last_error.z - error.z); // differential component
  
          memcpy(&self->last_error, &error, sizeof(error));
          self->last_update = current_tag;
          self->error_accumulator.x = self->error_accumulator.x + error.x;
          self->error_accumulator.y = self->error_accumulator.y + error.y;
          self->error_accumulator.z = self->error_accumulator.z + error.z;
  
          #ifndef NDEBUG
          lf_print("ANGLE = %f %f %f DESIRED ANGLE = %f %f %f MOTOR = %f %f %f", self->current_angle.x, self->current_angle.y, self->current_angle.z, self->desired_angle.x, self->desired_angle.y, self->desired_angle.z, control_signal->value.x, control_signal->value.y, control_signal->value.z);
          #endif
  
          lf_set_present(control_signal);
          WCET_END();
          WCET_REPORT(Controller);
      =}
  
  }
  
  reactor Motor(freq: float=1000.0, lfDeadline: time = 10 ms) {
      input in:FloatVec3
  
      @wcet("100 usec")
      reaction(in) {=
        lf_print("motor lag = %lli", lf_time_physical() - lf_time_logical());
        WCET_BEGIN();
        #ifndef NDEBUG
        lf_print("Got motor control input %f %f %f", in->value.x, in->value.y, in->value.z);
        #endif
  
        TAKE_TIME(500);
  
        PRINT_LAG(Motor);
        WCET_END();
        WCET_REPORT(Motor);
      =} deadline(lfDeadline) {=
          // lf_print_error_and_exit("deadline missd in Motor lag=" PRINTF_TIME, LAG());
          lf_print_error_and_exit("deadline missd in Motor");
      =}
  }
  
  reactor UserInput {
      output desired_angle: FloatVec3;
      @wcet("25 usec")
      reaction(startup) -> desired_angle {=
          desired_angle->value.x = 0.01;
          desired_angle->value.y = 0.02;
          desired_angle->value.z = 0.03;
          lf_set_present(desired_angle);
      =}
  }
  
  reactor Gyroscope(period=10ms) {
      timer t(10ms, period)
      state value: FloatVec3 = {0.01, 0.01, 0.01}
      output out: FloatVec3
  
      @wcet("50 usec")
      reaction(t) -> out {=
          WCET_BEGIN();
          PRINT_LAG(Gyro);
          TAKE_TIME(200);
          out->value.x = self->value.x;
          out->value.y = self->value.y;
          out->value.z = self->value.z;
          lf_set_present(out);
          WCET_END();
          WCET_REPORT(Gyro);
      =}
  }
  
  reactor AngularRateSensor(period=10ms) {
      timer t(10ms, period)
      state value: FloatVec3 = {0.1, 0.1, 0.1}
      output out: FloatVec3
  
      @wcet("50 usec")
      reaction(t) -> out {=
          WCET_BEGIN();
          PRINT_LAG(ARS);
          TAKE_TIME(200);
          out->value.x = self->value.x;
          out->value.y = self->value.y;
          out->value.z = self->value.z;
          lf_set_present(out);
          WCET_END();
          WCET_REPORT(ARS);
      =}
  }
  
  
  
  main reactor {
    controller = new Controller()
    userInput = new UserInput()
    gyro = new Gyroscope(period=1ms)
    ars = new AngularRateSensor(period=1ms)
    motor = new Motor(lfDeadline=2250usec)
  
    gyro.out -> controller.current_angle
    ars.out -> controller.current_speed
    userInput.desired_angle -> controller.desired_angle
    controller.control_signal -> motor.in
  
  }
  