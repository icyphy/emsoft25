/**
 * Micro-benchmark from the Savina benchmark suite.
 * Intended to measure message passing overhead by stress
 * testing the mailbox of actors.
 * See https://shamsimam.github.io/papers/2014-agere-savina.pdf.
 *
 * Lacking the mailbox in the reactor model this benchmarks
 * measures message passing overhead and scheduling overhead
 * because of the necessary scheduling after each message which
 * is not necessary in the actor model.
 *
 *
 * For comparison some informal results for 1,000,000 messages
 */
target C {
    files: ["../lib/benchmark_runner.h"],
    timeout: 13 sec,
    workers: 1,
}

import BenchmarkRunner from "../lib/BenchmarkRunner.lf";

preamble {=
    #include "benchmark_runner.h"
=}

realtime reactor ProducerReactor(countTo:size_t=1000000) {

    state i:size_t=0; // current counter value
    
    input inStartCounting:bool;
    input inResult:int;
    output outResetCounter:bool;
    output outIncrement:bool;
    output outRetrieveResult:bool;
    output finished:bool;

    // Replacing a logical action outFinishedCounting
    output outFinishedCountingOut: int;
    input outFinishedCountingIn: int;

    // Replacing a logical action count
    output countOut: int;
    input countIn: int;

    @wcet("7000 nsec")
    reaction(outFinishedCountingIn) -> finished {=
        // lf_print("%lld: Producer reaction 1", lf_time_logical_elapsed());
        //lf_request_stop();
        lf_set_present(finished);
    =}

    @wcet("7000 nsec")
    reaction(inStartCounting) -> countOut, outResetCounter {=
        // lf_print("%lld: Producer reaction 2", lf_time_logical_elapsed());
        // reset counter
        self->i = 0;
        lf_set_present(outResetCounter);
        lf_set_present(countOut);
    =}

    @wcet("7000 nsec")
    reaction(countIn) -> outIncrement, outRetrieveResult, countOut {=
        // lf_print("%lld: Producer reaction 3", lf_time_logical_elapsed());
        if(self->i < self->countTo) {
            lf_set_present(outIncrement);
            self->i += 1;
            lf_set_present(countOut);
        } else {
            lf_set_present(outRetrieveResult);
        }
    =}

    @wcet("20000 nsec")
    reaction(inResult) -> outFinishedCountingOut {=
        // lf_print("%lld: Producer reaction 4", lf_time_logical_elapsed());
        if(inResult->value != self->countTo) {
            printf("ProducerReactor expected %zu, found: %d\n",self->countTo, inResult->value);
        } else {
            printf("SUCCESS! received: %d \n", inResult->value);
        }
        lf_set_present(outFinishedCountingOut);
    =}
}

realtime reactor CountingReactor {

    input inReset:bool;
    input inIncrement:bool;
    input inRetrieveResult:bool;
    output outSendResult:int;


    state count:size_t=0;

    @wcet("16000 nsec")
    reaction(inRetrieveResult) -> outSendResult {=
        // lf_print("%lld: Counting reaction 1", lf_time_logical_elapsed());
        lf_set(outSendResult,self->count);
    =}

    @wcet("7000 nsec")
    reaction(inIncrement) {=
        // lf_print("%lld: Counting reaction 2", lf_time_logical_elapsed());
        self->count++;
    =}

    @wcet("7000 nsec")
    reaction(inReset) {=
        // lf_print("%lld: Counting reaction 3", lf_time_logical_elapsed());
        self->count = 0;
    =}
}

main reactor Counting(numIterations:size_t=12, countTo:size_t=1000)
{
    producer = new ProducerReactor(countTo = countTo);
    producer.outFinishedCountingOut -> producer.outFinishedCountingIn after 2 msec;
    producer.countOut -> producer.countIn after 2 msec;

    runner = new BenchmarkRunner(num_iterations=numIterations);

    runner.nextIterationOut -> runner.nextIterationIn after 2 msec;
    runner.doneOut -> runner.doneIn;

    runner.start -> producer.inStartCounting;
    producer.finished -> runner.finish;

    counter = new CountingReactor();

    producer.outIncrement -> counter.inIncrement;
    producer.outResetCounter -> counter.inReset;
    producer.outRetrieveResult -> counter.inRetrieveResult;
    counter.outSendResult -> producer.inResult;
}
