target C {
  scheduler: STATIC,
  build-type: Debug,
  platform: FlexPRET,
  files : ["synthetic_data.c", "synthetic_data.h"],
  cmake-include: "SatelliteAttitudeController.cmake",
  workers: 2,
}

preamble {=
  #include <string.h>
  #include <flexpret/flexpret.h>

  // Conveneince macros for calculating the current lag
  #define LAG() (rdtime() - ((uint32_t)lf_time_logical()))

  // Convenience macro for printing out the lag of a module. Uncomment to enable
  // #define PRINT_LAGS
  #ifdef PRINT_LAGS
  #define PRINT_LAG(module) lf_print("Lag in " #module " = %lu", LAG())
  #else
  #define PRINT_LAG(module) 
  #endif

  // Convenience macro to measure execution times of a module. Uncomment to enable
  // #define MEASURE_EXECUTION_TIMES
  #ifdef MEASURE_EXECUTION_TIMES
  #define EXEC_BEGIN() uint32_t __t1 = rdtime()
  #define EXEC_END() uint32_t __t2 = rdtime()
  #define EXEC_REPORT(module) lf_print("Execution time of " #module " = %lu", __t2 - __t1) 
  #else
  #define EXEC_BEGIN()
  #define EXEC_END()
  #define EXEC_REPORT(module)
  #endif

  // Convenience macro to simulate some execution time.
  #define TAKE_TIME(N) do {volatile int __x; for (int i = 0; i<N;i++) {__x++;}} while(0)    
  
  // Fixed point confuguration
  #define FIXED_POINT_FRACTION_BITS 12
  #define FIXED_POINT_SCALE (1 << FIXED_POINT_FRACTION_BITS)

  typedef struct {
    int x;
    int y;
    int z;
  } IntVec3;

=}

reactor Controller(period=100ms) {
    input current_angle: IntVec3
    input current_speed: IntVec3
    input desired_angle: IntVec3

    output control_signal: IntVec3

    state desired_angle: IntVec3
    state last_update: time = 0
    state last_error: IntVec3
    state error_accumulator: IntVec3

    state Kp: int = 0
    state Ki: int = 0
    state Kd: int = 0

    reaction(startup) {=
      self->Kp = -3.0 * FIXED_POINT_SCALE;
      self->Ki = -0.1 * FIXED_POINT_SCALE;
      self->Kd = 0 * FIXED_POINT_SCALE;

      #ifndef NDEBUG
      lf_print("Controller gains: Kp=%i Ki=%i Kd=%i", self->Kp, self->Ki, self->Kd);
      #endif
    =}


    reaction(desired_angle) {=
      self->desired_angle.x = desired_angle->value.x;
      self->desired_angle.y = desired_angle->value.y;
      self->desired_angle.z = desired_angle->value.z;

      #ifndef NDEBUG
      lf_print("Desired angle set to %i %i %i", self->desired_angle.x, self->desired_angle.y, self->desired_angle.z);
      #endif
    =}

    @wcet("700 usec")
    reaction(current_speed, current_angle) -> control_signal {=
        EXEC_BEGIN();
        IntVec3 error;

        #ifndef NDEBUG
        lf_print("Speed: %i %i %i Angle:  %i %i %i", current_speed->value.x, current_speed->value.y, current_speed->value.z, current_angle->value.x, current_angle->value.y, current_angle->value.z);
        #endif


        error.x = (current_angle->value.x - self->desired_angle.x);
        error.y = (current_angle->value.y - self->desired_angle.y);
        error.z = (current_angle->value.z - self->desired_angle.z);
        self->error_accumulator.x += error.x;
        self->error_accumulator.y += error.y;
        self->error_accumulator.z += error.z;

        #ifndef NDEBUG
        lf_print("Error = %i %i %i Accumulated: %i %i %i", error.x, error.y, error.z, self->error_accumulator.x, self->error_accumulator.y, self->error_accumulator.z);
        #endif

        control_signal->value.x =
              ((self->Kp * error.x) >> FIXED_POINT_FRACTION_BITS) 
            + ((self->Ki * self->error_accumulator.x) >>  FIXED_POINT_FRACTION_BITS) // integral component
            + ((self->Kd * (self->last_error.x - error.x)) >> FIXED_POINT_FRACTION_BITS); // differential component
        control_signal->value.y = 
              ((self->Kp * error.y)  >> FIXED_POINT_FRACTION_BITS)
            + ((self->Ki * self->error_accumulator.y) >> FIXED_POINT_FRACTION_BITS) // integral component
            + ((self->Kd * (self->last_error.y - error.y)) >> FIXED_POINT_FRACTION_BITS); // differential component
        control_signal->value.z = 
              ((self->Kp * error.z) >> FIXED_POINT_FRACTION_BITS)
            + ((self->Ki * self->error_accumulator.z) >> FIXED_POINT_FRACTION_BITS) // integral component
            + ((self->Kd * (self->last_error.z - error.z)) >> FIXED_POINT_FRACTION_BITS);


        self->last_error.x = error.x;
        self->last_error.y = error.y;
        self->last_error.z = error.z;
        #ifndef NDEBUG
        lf_print("Control = %i %i %i ", control_signal->value.x, control_signal->value.y, control_signal->value.z);
        #endif


        lf_set_present(control_signal);
        EXEC_END();
        EXEC_REPORT(Controller);
    =} 
}

reactor Motor(freq: float=1000.0, lfDeadline: time = 10 ms) {
    input in:IntVec3
    
    @wcet("100 usec")
    reaction(in) {=
      EXEC_BEGIN();
      #ifndef NDEBUG
      lf_print("Got motor control input %i %i %i", in->value.x, in->value.y, in->value.z);
      #endif

      TAKE_TIME(500);

      PRINT_LAG(Motor);
      EXEC_END();
      EXEC_REPORT(Motor);
    =} deadline(lfDeadline) {=
        // lf_print_error_and_exit("deadline missd in Motor lag=" PRINTF_TIME, LAG());
        lf_print_error_and_exit("deadline missd in Motor");
    =}
}

reactor UserInput {
    output desired_angle: IntVec3;
    @wcet("25 usec")
    reaction(startup) -> desired_angle {=
        desired_angle->value.x = 4096;
        desired_angle->value.y = 2048;
        desired_angle->value.z = 819;
        lf_set_present(desired_angle);
    =}
}

reactor Gyroscope(period: time =10ms) {
    timer t(10ms, period)
    output out: IntVec3
    state cnt: int = 0
    preamble{=
      #include "synthetic_data.h"
    =}

    @wcet("50 usec")
    reaction(t) -> out {=
        EXEC_BEGIN();
        PRINT_LAG(Gyro);      
        TAKE_TIME(200);
        out->value.x = synthetic_gyro[self->cnt][0];
        out->value.y = synthetic_gyro[self->cnt][1];
        out->value.x = synthetic_gyro[self->cnt][2];
        self->cnt++;
        if (self->cnt >= NUM_GYRO_SAMPLES) {
          self->cnt = 0;
        }
        lf_set_present(out);
        EXEC_END();
        EXEC_REPORT(Gyro);
    =}
}

reactor AngularRateSensor(period: time =10ms) {
    timer t(10ms, period)
    output out: IntVec3

    @wcet("50 usec")
    reaction(t) -> out {=
        EXEC_BEGIN();
        PRINT_LAG(ARS);
        TAKE_TIME(200);
        out->value.x = 100;
        out->value.y = 200;
        out->value.z = 300;
        lf_set_present(out);
        EXEC_END();
        EXEC_REPORT(ARS);
    =}
}



main reactor {
  controller = new Controller()
  userInput = new UserInput()
  gyro = new Gyroscope(period=1ms)
  ars = new AngularRateSensor(period=1ms)
  motor = new Motor(lfDeadline=600msec)

  gyro.out -> controller.current_angle
  ars.out -> controller.current_speed
  userInput.desired_angle -> controller.desired_angle
  controller.control_signal -> motor.in

}
